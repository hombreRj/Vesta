package gg.scenarios.vesta.exploits;

import com.comphenix.protocol.PacketType;
import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.ProtocolManager;
import com.comphenix.protocol.events.ListenerPriority;
import com.comphenix.protocol.events.PacketAdapter;
import com.comphenix.protocol.events.PacketContainer;
import com.comphenix.protocol.events.PacketEvent;
import com.comphenix.protocol.utility.StreamSerializer;
import com.comphenix.protocol.wrappers.nbt.NbtCompound;
import com.comphenix.protocol.wrappers.nbt.NbtFactory;
import com.comphenix.protocol.wrappers.nbt.NbtList;
import com.google.common.base.Charsets;
import com.google.gson.Gson;
import io.netty.buffer.ByteBuf;
import org.bukkit.Bukkit;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;

import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import gg.scenarios.vesta.Vesta;

public class CustomPayloadFixer {
    public CustomPayloadFixer(Vesta plugin) {
        ProtocolManager manager = ProtocolLibrary.getProtocolManager();

        manager.addPacketListener(new PacketAdapter(plugin, PacketType.Play.Client.CUSTOM_PAYLOAD) {
            @Override
            public void onPacketReceiving(PacketEvent event) {
                checkPacket(event);
            }
        });

        manager.addPacketListener(new PacketAdapter(plugin, ListenerPriority.NORMAL, PacketType.Play.Client.POSITION) {
            @Override
            public void onPacketReceiving(PacketEvent event) {
                if (!event.getPacketType().equals(PacketType.Play.Client.POSITION)) {
                    return;
                }

                try {
                    int before = event.getPlayer().getLocation().getBlockY();
                    int next = event.getPacket().getDoubles().read(1).intValue();

                    if (before + 200 < next) {
                        event.setCancelled(true);
                    }
                } catch (Exception ignored) {}
            }
        });

        plugin.getServer().getScheduler().runTaskTimer(plugin, () -> {
            for (Iterator<Entry<Player, Long>> iterator = PACKET_USAGE.entrySet().iterator(); iterator.hasNext(); ) {
                Player player = iterator.next().getKey();

                try {
                    if (!player.isOnline() || !player.isValid()) {
                        iterator.remove();
                    }
                } catch (Exception ignored) {}
            }
        }, 20L, 20L);
    }

    // private static final Pattern COLOR_PATTERN = Pattern.compile("(?i)ยง[0-9A-FK-OR]");
    private static final Map<Player, Long> PACKET_USAGE = new ConcurrentHashMap<>();

    private void checkPacket(PacketEvent event) {
        Player player = event.getPlayer();

        if (player == null) {
            return;
        }

        long lastPacket = PACKET_USAGE.getOrDefault(player, -1L);

        // This fucker is already detected as an exploiter
        if (lastPacket == -2L) {
            event.setCancelled(true);
            return;
        }

        String name = event.getPacket().getStrings().readSafely(0);

        if (!"MC|BSign".equals(name) && !"MC|BEdit".equals(name) && !"REGISTER".equals(name)) {
            return;
        }

        try {
            if ("REGISTER".equals(name)) {
                checkChannels(event);
            } else {
                if (elapsed(lastPacket)) {
                    PACKET_USAGE.put(player, System.currentTimeMillis());
                } else {
                    throw new IOException("Packet flood");
                }

                checkNbtTags(event);
            }
        } catch (Throwable ex) {
            // Set last packet usage to -2 so we wouldn't mind checking him again
            PACKET_USAGE.put(player, -2L);
            event.setCancelled(true);

            if (player.getName().startsWith("UNKNOWN[")) {
                return;
            }

            Bukkit.getServer().getScheduler().runTask(Vesta.getInstance(), () -> Vesta.getInstance().getServer().dispatchCommand(Vesta.getInstance().getServer().getConsoleSender(), "litebans:ban " + player.getName() + " crash_glitch"));
            Vesta.getInstance().getServer().getLogger().log(Level.WARNING, player.getName() + " tried to exploit CustomPayload: " + ex.getMessage(), ex);
            Vesta.getInstance().getRedis().getClient().getTopic("serverErrors").publishAsync(Vesta.getInstance().getGson().toJson(new Exploit(player.getName() + " tried to exploit CustomPayload: " + ex.getMessage(), Vesta.getInstance().getServerManager().getServerName(), "WARNING", ex.getStackTrace().toString())));
        }
    }

    @SuppressWarnings("deprecation")
    private void checkNbtTags(PacketEvent event) throws IOException {
        PacketContainer container = event.getPacket();
        ByteBuf buffer = container.getSpecificModifier(ByteBuf.class).read(0).copy();

        byte[] bytes = new byte[buffer.readableBytes()];
        buffer.readBytes(bytes);

        try (DataInputStream inputStream = new DataInputStream(new ByteArrayInputStream(bytes))) {
            ItemStack itemStack = StreamSerializer.getDefault().deserializeItemStack(inputStream);

            if (itemStack == null) {
                throw new IOException("Unable to deserialize ItemStack");
            }

            NbtCompound root = (NbtCompound) NbtFactory.fromItemTag(itemStack);

            if (root == null) {
                throw new IOException("No NBT tag?!");
            } else if (!root.containsKey("pages")) {
                throw new IOException("No 'pages' NBT compound was found");
            } else {
                NbtList<String> pages = root.getList("pages");

                if (pages.size() > 50) {
                    throw new IOException("Too many pages");
                }
            }
        } finally {
            buffer.release();
        }
    }

    private void checkChannels(PacketEvent event) throws Exception {
        int channelsSize;

        try {
            channelsSize = event.getPlayer().getListeningPluginChannels().size();
        } catch (UnsupportedOperationException ex) {
            channelsSize = 0;
        }

        PacketContainer container = event.getPacket();
        ByteBuf buffer = container.getSpecificModifier(ByteBuf.class).read(0).copy();

        try {
            for (int i = 0; i < buffer.toString(Charsets.UTF_8).split("\0").length; i++) {
                if (++channelsSize > 124) {
                    throw new IOException("Too many channels");
                }
            }
        } finally {
            buffer.release();
        }
    }

    private boolean elapsed(long from) {
        return from == -1L || System.currentTimeMillis() - from > 100L;
    }
}
